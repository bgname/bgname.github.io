---
layout: post
title:  "消息提醒"
date:   2020-04-21 12:12:00 +0800
categories: jekyll update
---

### 消息提醒

#### 一、功能扩展

消息提醒分为 **提醒**和**定时器**，所有的消息提醒都要 继承 BaseTaskProcessor

1. 在TaskTypeEnum 枚举中添加 自己自定义提醒的类型枚举，TIMING结尾是定时器，REMIND结尾是提醒。

2. 新建一个用来执行具体任务的提醒类，并继承BaseTaskProcessor

3. BaseTaskProcessor方法说明：

   * ```java
     Date getNextStartTime(Date taskStartDate)  
     ```

     * 获取下次任务开始时间
     * 如果是一次性任务, 直接返回null, 即不重写这个方法

   * ```java
     protected boolean process(TaskSubject taskSubject)
     ```

     * 执行定时任务，定时时间到了后该执行的任务
     * **注意**： 这个接口的实现一定要是幂等的, 因为有被重复执行的可能
     * 多数任务为普通的提醒任务, 不用执行任何多余操作, 直接返回 成功 , 即不重写这个方法

   * ```java
     public abstract List<String> getStaffList(String bizId);
     ```

     * 根据一个业务id获取所有的需要提醒的员工
     * 例如**面试提醒**相关的员工就是：负责此项目的客服专员，主管，经理

   * ```java
     public abstract Map<String, RemindVO> listRemind(List<String> bizIds);
     ```

     * 根据业务id获取每个业务id对应的业务数据

4. 建无参构造器，调用父类（BaseTaskProcessor）的构造器，super(自定义提醒类型枚举，提前提醒毫秒数【不传默认为半小时，一般为立即提醒】)

5. 提醒：

   * getStaffList()：查询提醒相关的内部员工id，例如 面试提醒，需要查询负责这个岗位招聘的**客服负责人**
   * listRemind()：查询提醒的相关数据，面试提醒 需要返回 面试时间，人数等

6. 定时器：

   * process()：执行定时任务，例如 职位下线定时器，时间到了就修改 岗位的状态

7. 在需要生成提醒或定时器的地方使用  

```java
ScheduledTaskUtils.sendTask(@NonNull TaskTypeEnum taskType, @NonNull String bizId, Date targetTime, long executeStartTime, long executeEndTime, TimeUnit timeUnit);
```

* taskType： 提醒类型的枚举
* bizId： 业务id，例：职位下线提醒定时器的业务id：employId（要下线的岗位id）
* targetTime：定时任务参照时间，targetTime 为空，则以当前时间为参照时间
* executeStartTime：定时任务开始时间。
* executeEndTime ：定时任务结束时间，如果没有结束时间, 那开始时间和结束时间一致
* timeUnit：时间类型

#### 二、注意事项

1. 所有自定义的提醒和定时器 都需要注入到IOC容器中，否者无法获取到自定义的提醒或者定时器。
2. 所有的提醒返回给前端的提醒相关数据都以RemindVO为基类。
3. 在做定时器的时候，一个定时器的相关内部员工可能会有多个，这个时候生成的定时器也会有多个，每一个相关的内部员工都会生成一个定时器，这时定时器会执行多次，需要注意对于结果是否会有影响
4. 提醒都是立即提醒。

#### 三、使用方法

```java
@Component    //创建自定义的类继承BaseTaskProcessor
public class PostOffLineTimingProcessor extends BaseTaskProcessor {

    @Autowired
    private EmployJobService employJobService;
	
    /**
    *  调用父类构造器生成一个自定义类型的提醒或者定时器
    */
    public PostOffLineTimingProcessor() {
        super(TaskTypeEnum.POST_OFFLINE_TIMING, 0L);
    }
	/**
	*  查询提醒相关内部员工id
	*/
    @Override
    public List<String> getStaffList(String bizId) {
        return Lists.newArrayList(employJobService.getOne(new LambdaQueryWrapper<EmployJob>().eq(EmployJob::getEmployId, bizId)).getPublishStaffId());
    }
	/**
	*  查询提醒相关信息
	*/
    @Override
    public Map<String, RemindVO> listRemind(List<String> bizIds) {
        return Maps.newHashMap();
    }
	
    /**
    *  定时器需要执行的任务
    *  职位下线，修改这个职位的状态为 下线
    */
    @Override
    protected boolean process(TaskSubject taskSubject) {
        employJobService.update(new LambdaUpdateWrapper<EmployJob>()
                .set(EmployJob::getEmployProcess, EmployProcessEnum.OFFLINE)
                .eq(EmployJob::getEmployId, taskSubject.getBizId()));
        return true;
    }
}
```

